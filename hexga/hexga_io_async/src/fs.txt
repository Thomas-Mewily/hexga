use super::*;

pub type Path = String;
#[allow(non_camel_case_types)]
pub type path = str;

pub type Extension = String;
#[allow(non_camel_case_types)]
pub type extension = str;

pub type IoResult<T=()> = Result<T,IoError>;

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct IoError
{
    pub path: Path,
    pub kind: IoErrorKind,
    pub childs: Vec<IoError>
}
impl IoError
{
    pub fn new(path: impl Into<Path>, kind: IoErrorKind) -> Self { Self { path: path.into(), kind, childs: vec![] }}
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]

pub enum IoErrorKind
{
    #[default]
    Unknow,
    NotFound,
    Encoding,
    UnknowExtension { got:Extension, expected:Vec<Extension> }
}


pub type FsRead = dyn IoRead;
/// Shared behavior of a FileSystem when reading and writing
pub trait IoRead
{
    fn absolute_path(&self, path: &path) -> Option<Path>
    {
        match std::path::absolute(path)
        {
            Ok(v) => v.to_str().map(|v| v.to_owned()),
            Err(_) => None,
        }
    }

    fn have_permission_to_read(&self, path: &path) -> IoResult { let _ = path; Ok(()) }

    /// The permission are checked when calling this function
    fn read_bytes(&mut self, path: &path) -> IoResult<Vec<u8>>
    {
        let _ = self.have_permission_to_read(path)?;
        unsafe { self.read_bytes_unchecked(path) }
    }

    /// The permission was not checked when calling this function
    ///
    /// Also see [`IoFsRead::read_bytes()`] to check the permission
    unsafe fn read_bytes_unchecked(&mut self, path: &path) -> IoResult<Vec<u8>>;
}

pub type FsWrite = dyn IoWrite;
pub trait IoWrite : IoRead
{
    fn have_permission_to_write(&self, path: &path) -> IoResult { let _ = path; Ok(()) }

    /// The permission are checked when calling this function
    fn write_bytes(&mut self, path: &path, data: &[u8]) -> IoResult
    {
        self.have_permission_to_write(path)?;
        unsafe { self.write_bytes_unchecked(path, data) }
    }

    /// The permission was not checked when calling this function
    ///
    /// Also see [`IoFsRead::read_bytes()`] to check the permission
    unsafe fn write_bytes_unchecked(&mut self, path: &path, data: &[u8]) -> IoResult;
}

pub struct Io;
impl Io
{
    /// Used for loading and saving on the long term.
    ///
    /// Don't include the `.bin` extension, not made for storing stuff for the long term
    pub const MARKUP_EXTENSIONS: &'static [&'static str] =
    &[
        #[cfg(feature = "serde_ron")]
        Self::RON_EXTENSION,
        #[cfg(feature = "serde_json")]
        Self::JSON_EXTENSION,
        #[cfg(feature = "serde_xml")]
        Self::XML_EXTENSION,

        /* Not one of them
        #[cfg(feature = "serde_quick_bin")]
        Self::QUICK_BIN_EXTENSION,
        */
    ];

    #[cfg(feature = "serde_json")]
    pub const JSON_EXTENSION : &'static str = "json";
    #[cfg(feature = "serde_ron")]
    pub const RON_EXTENSION  : &'static str = "ron";
    #[cfg(feature = "serde_xml")]
    pub const XML_EXTENSION  : &'static str = "xml";


    #[cfg(feature = "serde_quick_bin")]
    pub const QUICK_BIN_EXTENSION  : &'static str = "bin";
}


pub trait IoLoad : for<'de> Deserialize<'de>
{
    /// Dedicated file extension to load the value. ex `png`, `jpeg` for image
    ///
    /// Don't include the markup language extension like `json` or `ron`
    ///
    /// The first value also determines the default extension in [IoLoad::load_default_extension].
    fn load_custom_extensions() -> impl Iterator<Item = &'static str> { std::iter::empty() }


    fn load_from_fs(path: &Path, fs: &mut FsWrite) -> IoResult<Self>
    {
        fs.read_bytes(path)
    }

    /// Support bytes and str
    fn load_from_bytes(data: &[u8], path: &path) -> IoResult<Self>
    {
        Self::load_from_bytes_with_extension(data, path, path.extension_or_empty())
    }

    fn load_from_bytes_with_extension(data: &[u8], path : &path, extension : &extension) -> IoResult<Self>
    {
        let _ = data;
        Err(IoError::new(path, IoErrorKind::UnknowExtension { got: extension.into(), expected: Self::load_extensions().map(|e| e.to_owned()).collect() }))
    }

    fn load_from_bytes_with_custom_extension(data: &[u8], path : &path, extension : &extension) -> IoResult<Self>
    {
        let _ = data;
        Err(IoError::new(path, IoErrorKind::UnknowExtension { got: extension.into(), expected: Self::load_extensions().map(|e| e.to_owned()).collect() }))
    }

    /// Don't include the markup language extension like `json` or `ron`
    fn can_open_own_extension(extension: &str) -> bool { Self::load_custom_extensions().any(|ext| ext == extension) }

    /// Also include the markup language extension like `json` or `ron`
    fn load_extensions() -> impl Iterator<Item = &'static str> { Self::load_custom_extensions().chain(Io::MARKUP_EXTENSIONS.iter().copied()) }

    /// Also include the markup language extension like `json` or `ron`
    fn can_open_extension(extension: &str) -> bool { Self::load_extensions().any(|ext| ext == extension) }

}