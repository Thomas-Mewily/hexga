#![allow(unused_imports)]
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_mut)]

use std::{any::{Any, TypeId}, env::var, io::BufWriter, ops::{Deref, DerefMut}};

use hexga::{io::{asset::AssetError, fs::{Fs, FsDisk}}, prelude::*};

use ron::ser::PrettyConfig;
use serde::ser::{SerializeMap, SerializeSeq, SerializeStructVariant, SerializeTuple, SerializeTupleStruct, SerializeTupleVariant};
pub use serde::{Serialize, Serializer, Deserialize, Deserializer, de::Visitor, ser::SerializeStruct};

struct FileSerializerFs<F>
{
    path: Path,
    fs: F,
    field_name: Option<&'static str>,
}

struct FileSerializer<F,S>
    where
    F: FsWrite,
    // for<'a> &'a mut S: Serializer,
    // S: MarkupSerializer
{
    fs: FileSerializerFs<F>,
    serializer: S,
}

type JsonSerializer = serde_json::Serializer<Vec<u8>>;

// pub trait MarkupSerializer : Sized
// {
//     fn to_markup(self) -> Result<String, ()>;
// }
// impl MarkupSerializer for JsonSerializer
// {
//     fn to_markup(self) -> Result<String, ()> {
//         let bytes = self.into_inner();
//         String::from_utf8(bytes).map_err(|_| ())
//     }
// }


// pub trait SerializerProvider
// {
//     type
// }

// pub trait GenerateSerialize
// {
//     type Serializer :
//     fn generate_serializer(self) ->
// }

// pub trait MarkupSerializer : Sized
// {
//     type Error: serde::ser::Error;
//     type Serializer<'a> : Serializer<Error = Self::Error> where Self: 'a;

//     fn serializer<'a>(&'a self) -> Self::Serializer<'a>;

//     fn to_markup_in<T>(self, value: &T, markup: String) -> Result<String, Self::Error> where T:Serialize;
//     fn to_markup<T>(self, value: &T) -> Result<String, Self::Error> where T:Serialize
//     {
//         self.to_markup_in(value, String::with_capacity(4096) )
//     }
// }

// struct RonSerializer;


// impl MarkupSerializer
// {
//     pub(crate) fn _serialize_val<T>(self, value: &T) where T: Serialize
//     {

//     }
// }

// impl MarkupSerializer for RonSerializer
// {
//     type Error = ron::error::Error;

//     fn to_markup_in<T>(self, value: &T, mut markup: String) -> Result<String, Self::Error>
//         where T:Serialize
//     {
//         let mut serializer = ron::ser::Serializer::new(&mut markup, None)?;
//         value.serialize(&mut serializer)?;
//         Ok(markup)
//     }

//     type Serializer<'a> = ron::ser::Serializer<&'a mut String>  where Self: 'a;

//     fn serializer<'a>(&'a self) -> Self::Serializer<'a> {
//         todo!()
//     }
// }
// impl MarkupSerializer for JsonSerializer
// {
//     type Error = serde_json::Error;

//     fn to_markup_in<T>(self, value: &T, mut markup: String) -> Result<String, Self::Error>
//         where T:Serialize
//     {
//         let mut bytes= Vec::with_capacity(2048);
//         let mut serializer = serde_json::ser::Serializer::new(&mut bytes);
//         value.serialize(&mut serializer)?;
//         markup.push_str(&String::from_utf8(bytes).unwrap());
//         Ok(markup)
//     }
// }


impl<F,S> FileSerializer<F,S>
    where
    F: FsWrite
{
    pub fn new(fs: F, serializer: S) -> Self { Self::with_path(String::new(), fs, serializer) }
    pub fn with_path(path: Path, fs: F, serializer: S) -> Self { Self { fs: FileSerializerFs { path, fs, field_name: None }, serializer }}
}


impl<'a,F,S> SerializeSeq for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeSeq// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_element<T>(&mut self, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize
    {
        let FileSerializer { fs, serializer } = self;
        //serializer.to_markup_in(&v, fs.buf).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        let _ok = serializer.serialize_element(value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error>
    {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }
}

impl<'a,F,S> SerializeTuple for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeTuple// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_element<T>(&mut self, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.serialize_element(value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }
}


impl<'a,F,S> SerializeTupleStruct for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeTupleStruct// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_field<T>(&mut self, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.serialize_field(value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }
}

impl<'a,F,S> SerializeTupleVariant for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeTupleVariant// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_field<T>(&mut self, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.serialize_field(value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }
}

impl<'a,F,S> SerializeMap for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeMap// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_key<T>(&mut self, key: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.serialize_key(key).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn serialize_value<T>(&mut self, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.serialize_value(value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }
}

impl<'a,F,S> SerializeStruct for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeStruct// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.serialize_field(key, value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error>
    {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }
}

impl<'a,F,S> SerializeStructVariant for FileSerializer<F,S>
    where
    F: FsWrite,
    S: SerializeStructVariant// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>
    where
        T: ?Sized + Serialize
    {

        let FileSerializer { fs, serializer } = self;
        //fs.path = fs.path.as_str().path_concat(name);
        let _ok = serializer.serialize_field(key, value).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(())
    }

    fn end(self) -> Result<Self::Ok, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let _ok = serializer.end().map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        // extract the json / ron and save it here
        Ok(())
    }
}


/*
fn get_str<T,S>(val:&T,s:S) where S: Serializer
{

}

trait StringSerializer
{
    type Error;
    fn serialize_to_string<T: Serialize>(self, value: &T) -> Result<String, Self::Error>;
}

fn serializable_string<S,T>(serializer: S, buf: &mut String, value: &T) -> Result<(),S::Error> where S: Serializer, T:Serialize
{

}*/



/*
impl StringSerializer for &mut ron::Serializer<String>
{
    type Error=IoError;
    fn serialize_to_string<T: Serialize>(self, string value: &T) -> Result<String, Self::Error>
    {
        value.serialize(self).map_err(|e| IoError::from_display(e))?;
        todo!()
    }
}
*/

impl<F,S> FileSerializer<F,S> where
    F: FsWrite,
    S: Serializer
{
    pub(crate) fn _ron_serialiser(buf: &mut String) -> ron::Serializer<&mut String>
    {
        ron::Serializer::new(buf, None).unwrap()
    }


    pub(crate) fn _serialize_primitive<T>(mut self, val: &T) -> Result<<Self as Serializer>::Ok, <Self as Serializer>::Error>
        where T:Serialize
    {
        let mut s = JsonSerializer::new(___());
        val.serialize(&mut s).map_err(|e| AssetError{ path: self.fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        //let json = s.to_markup().map_err(|e| AssetError{ path: self.fs.path.clone(), ..___() })?;
        self.fs.fs.write_bytes(&self.fs.path, &s.into_inner()).map_err(|kind| AssetError{ path: self.fs.path.clone(), kind, ..___() })
    }
}

// A simple example for our format: key=value;key=value
impl<F,S> Serializer for FileSerializer<F,S>
    where
    F: FsWrite,
    S: Serializer,// + MarkupSerializer
{
    type Ok = ();
    type Error = AssetError;

    type SerializeSeq = FileSerializer<F,S::SerializeSeq>;
    type SerializeTuple = FileSerializer<F,S::SerializeTuple>;
    type SerializeTupleStruct = FileSerializer<F,S::SerializeTupleStruct>;
    type SerializeTupleVariant = FileSerializer<F,S::SerializeTupleVariant>;
    type SerializeMap = FileSerializer<F,S::SerializeMap>;
    type SerializeStruct = FileSerializer<F,S::SerializeStruct>;
    type SerializeStructVariant = FileSerializer<F,S::SerializeStructVariant>;

    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&v)
    }

    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {
        todo!()
        //self._serialize_primitive(&None)
    }

    fn serialize_some<T>(self, v: &T) -> Result<Self::Ok, Self::Error>
    where
        T: ?Sized + Serialize {
        self._serialize_primitive(&v)
    }

    fn serialize_unit(self) -> Result<Self::Ok, Self::Error>
    {
        self._serialize_primitive(&())
    }

    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error> {
        self._serialize_primitive(&())
    }

    fn serialize_unit_variant(
        self,
        name: &'static str,
        variant_index: u32,
        variant: &'static str,
    ) -> Result<Self::Ok, Self::Error> {
        todo!()
    }

    fn serialize_newtype_struct<T>(
        self,
        name: &'static str,
        value: &T,
    ) -> Result<Self::Ok, Self::Error>
    where
        T: ?Sized + Serialize {
        todo!()
    }

    fn serialize_newtype_variant<T>(
        self,
        name: &'static str,
        variant_index: u32,
        variant: &'static str,
        value: &T,
    ) -> Result<Self::Ok, Self::Error>
    where
        T: ?Sized + Serialize {
        todo!()
    }

    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let serializer = serializer.serialize_seq(len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }

    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let serializer = serializer.serialize_tuple(len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }

    fn serialize_tuple_struct(
        self,
        name: &'static str,
        len: usize,
    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let serializer = serializer.serialize_tuple_struct(name, len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }

    fn serialize_tuple_variant(
        self,
        name: &'static str,
        variant_index: u32,
        variant: &'static str,
        len: usize,
    ) -> Result<Self::SerializeTupleVariant, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let serializer = serializer.serialize_tuple_variant(name, variant_index, variant, len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }

    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let serializer = serializer.serialize_map(len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }

    fn serialize_struct(
        self,
        name: &'static str,
        len: usize,
    ) -> Result<Self::SerializeStruct, Self::Error>
    {
        let Self { mut fs, serializer } = self;
        let serializer = serializer.serialize_struct(name, len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }

    fn serialize_struct_variant(
        self,
        name: &'static str,
        variant_index: u32,
        variant: &'static str,
        len: usize,
    ) -> Result<Self::SerializeStructVariant, Self::Error> {
        let FileSerializer { fs, serializer } = self;
        let serializer = serializer.serialize_struct_variant(name, variant_index, variant, len).map_err(|e| AssetError{ path: fs.path.clone(), kind: IoError::from_display(e), ..___() })?;
        Ok(FileSerializer{fs, serializer})
    }
}

#[derive(Serialize, Deserialize)]
struct Person
{
    age: i32,
    name: String,
}


fn t()
{
    // let my_struct = Person {
    //     name: "Alice".into(),
    //     age: 30,
    // };

    // let mut s = String::new();
    // // let mut ron = ron::ser::Serializer::new(&mut s, None).unwrap();
    // // my_struct.serialize(&mut ron).unwrap();

    // // //dbg!(r);
    // // println!("{s}");

    // s.clear();


    // let mut ron = ron::ser::Serializer::new(&mut s, None).unwrap();
    // let mut meta_ron = FileSerializer::with_path("./tmp/io_serde/test".to_owned(), FsDisk, &mut ron);

    // true.serialize(meta_ron).unwrap();
    // //my_struct.serialize(meta_ron).unwrap();
    // println!("{s}");


    // let mut buf = String::new();
    // let mut ron_serializer = ron::ser::Serializer::new(&mut buf, None).unwrap();
    // true.serialize(&mut ron_serializer).unwrap();
    // println!("{buf}")

    // let mut f = SerdeAssetSerializer::ron(FsDisk);
    // let r = my_struct.serialize(&mut f);
    // dbg!(&r);
}

fn test_serialize(val: impl Serialize)
{
    // let mut buf = String::new();
    // let mut ron_serializer = ron::ser::Serializer::new(&mut buf, None).unwrap();
        // let mut buf = String::new();
    // let mut ron_serializer = ron::ser::Serializer::new(&mut buf, None).unwrap();
    let file_serializer = FileSerializer::with_path("./tmp/io_serde/test".to_owned(), FsDisk, &mut ron_serializer);
    val.serialize(file_serializer).unwrap();
}


fn main()
{

    //let c : serde_json::ser::Compound<'static,String,serde_json::ser::CompactFormatter> = serde_json::ser::Compound::
    //test_serialize(true);
    //test_serialize("ok");

    let my_struct = Person {
        name: "Alice".into(),
        age: 30,
    };

    println!("{}", my_struct.to_ron().unwrap());
    test_serialize(my_struct);


    println!("hello world");
}
